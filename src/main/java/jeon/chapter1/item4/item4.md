

# **아이템4: 인스턴스화를 막으려거든 private 생성자를 사용하라**

> 인스턴스화(instance instantiation)는 클래스의 정의를 기반으로 실제 객체를 메로리에 생성하는 과정이다. 클래스의 인스턴스화를 막기위해 private 생성자를 사용하는 것은 클래스를 외부에서 인스턴스화하는 것을 방지하기 위한 테크닉이다. 클래스에 정의된 생성자가 모두 'private'으로 선언되면, 그 클래스는 외부에서 객체를 생성할 수 없게 된다. 이러한 접근 제한자를 사용하는 것은 주로 유틸리티 클래스나 상수만을 포함하는 클래스와 같이 인스턴스화될 필요가 없는 클래스들에 적용된다.

<br>

**1\. 정적 메서드와 정적 필드만을 담은 클래스의 예시**

-   기본 타입 값이나 배열 관련 메서들을 모아놓을 때 : java.lang.Math, java.util.Arrays
-   특정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드(혹은 팩터리)를 모아놓을 때 : java.util.Collections
-   final 클래스와 관련한 메서드들을 모아놓을 때 ➜ final 클래스를 상속해서 하위 클래스에 메서드를 넣는 것이 불가능하기 때문에
-   **추상클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.** 하위 클래스를 만들어 인스턴스화 할 수 있기 때문이다. 또한 사용자에서 상속해서 쓰라는 오해를 불러올 수 있다.

<br>


**2\. 인스턴스화를 막기 방법 private 생성자**

-   생성자를 명시하지 않으면 컴파일러는 자동으로 기본 생성자를 만들어 준다. 즉, 매개변수를 받지 않는 public 생성자가 만들어지게 된다. 이 때 사용자는 이 생성자가 자동 생성된 것인지 구분할 수 없게 된다.
-   컴파일러가 기본 생성자를 만드는 경우는 오직 명시된 생성자가 없을 때 뿐이므로 private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.
-   생성자 내부에 AssertionError를 던지는 것은, 만약 클래스 내부나 리플렉션을 통해 인스턴스화를 시도할 경우에 에러를 발생시키기 위한 추가적인 방어층이다. 
-   이와 같은 방식을 통해 유틸리티 클래스가 실수로 객체로 생성되는 것을 방지하고 클래스의 정적 메서드와 변수만을 사용하도록 강제한다. 하위 클래스가 상위 클래스의 생성자에 접근할 수 없으므로 상속을 막을 수 있다.
-   그런데 생성자가 분명 존재하는데 호출할 수는 없다니, 그다지 직관적이지 않다. <span style="color:blue"> **주석을 만드시 달아주자!**</span>

<br>


```java
public class UtilityClass {

    // 기본 생성자가 만들어 지는 것을 막는다(인스턴스 방지용)
    private UtilityClass() {
        throw new AssertionError("UtilityClass should not be instantiated!");
    }

    public static int add(int a, int b) {
        return a + b;
    }

    public static int subtract(int a, int b) {
        return a - b;
    }
}
```